🌱 Step 1: What is Dynamic Programming?

Dynamic Programming (DP) is a way to solve problems by breaking them down into smaller overlapping subproblems, solving each subproblem only once, and reusing the results (instead of recalculating).

Think of it like:
Instead of re-solving the same homework question again and again, you save the answer and reuse it later.

🌱 Step 2: Where do we use DP?

We use DP when:

Optimal substructure: The solution to a problem depends on solutions to smaller subproblems.

Overlapping subproblems: We keep solving the same smaller problems multiple times.

🌱 Step 3: Fibonacci Example (Classic DP Intro)

Problem: Find the nth Fibonacci number.
Fibonacci sequence:

0, 1, 1, 2, 3, 5, 8, 13, ...
F(n) = F(n-1) + F(n-2)

❌ Naive Recursion
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}


fib(5) calls fib(4) and fib(3).

But fib(4) again calls fib(3) and fib(2).

So fib(3) is calculated many times → exponential time O(2^n). Very slow.

✅ DP with Memoization (Top-Down)

We save already computed results.

function fib(n, memo = {}) {
    if (n in memo) return memo[n];
    if (n <= 1) return n;

    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}

console.log(fib(10)); // 55


Store answers in memo (a JS object).

If we already solved it → return the stored result.

Complexity: O(n).

✅ DP with Tabulation (Bottom-Up)

We build the solution iteratively.

function fib(n) {
    if (n <= 1) return n;
    let dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

console.log(fib(10)); // 55


Build an array dp.

Start from small subproblems and build upward.

Complexity: O(n), space O(n).

Can optimize to O(1) space using two variables.

🌱 Step 4: How to Recognize a DP Problem

Ask yourself:

Can I break this problem into smaller subproblems?

Am I solving the same subproblem multiple times?

Does the problem ask for an optimal result (max/min/longest/shortest/count ways)?

If yes → very likely a DP problem.

🌱 Step 5: DP Problem Types

Most DP problems fall into a few patterns:

Fibonacci-like (1D DP) – depends on previous results.

Knapsack-like (Subset DP) – choose or not choose items.

Grid DP (paths in a matrix).

String DP (subsequences, palindromes, edit distance).

Interval DP (partitioning problems).